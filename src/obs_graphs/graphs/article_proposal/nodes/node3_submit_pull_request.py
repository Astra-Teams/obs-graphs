"""Agent responsible for committing changes and creating a GitHub pull request."""

from __future__ import annotations

from datetime import datetime, timezone

from src.obs_graphs.graphs.article_proposal.state import (
    AgentResult,
    FileAction,
    FileChange,
)
from src.obs_graphs.protocols import GithubServiceProtocol, NodeProtocol
from src.obs_graphs.settings import get_settings


class SubmitPullRequestAgent(NodeProtocol):
    """Aggregate node that pushes workflow changes to GitHub."""

    name = "submit_pull_request"

    def __init__(self, github_service: GithubServiceProtocol):
        self._github_service = github_service
        self._settings = get_settings()

    def validate_input(self, context: dict) -> bool:
        required_keys = ["strategy", "accumulated_changes", "node_results"]
        return all(key in context for key in required_keys)

    def execute(self, context: dict) -> AgentResult:
        if not self.validate_input(context):
            raise ValueError(
                "Invalid context: strategy, accumulated_changes, and node_results are required"
            )

        strategy: str = context["strategy"]
        accumulated_changes: list[FileChange] = context["accumulated_changes"]
        node_results: dict = context["node_results"]

        if not accumulated_changes:
            return AgentResult(
                success=True,
                changes=[],
                message="No changes detected; skipping GitHub submission",
                metadata={"branch_name": "", "pr_url": ""},
            )

        try:
            commit_message = self._generate_commit_message(
                strategy, node_results, accumulated_changes
            )
            pr_title, pr_body = self._generate_pr_content(
                strategy, node_results, accumulated_changes
            )
            branch_name = self._generate_branch_name()
            base_branch = self._settings.workflow_default_branch

            pr_url = self._github_service.commit_and_create_pr(
                branch_name=branch_name,
                base_branch=base_branch,
                changes=accumulated_changes,
                commit_message=commit_message,
                pr_title=pr_title,
                pr_body=pr_body,
            )

            message = (
                f"Pull request created successfully: {pr_url}"
                if pr_url
                else "GitHub submission completed without PR creation"
            )

            return AgentResult(
                success=True,
                changes=[],
                message=message,
                metadata={
                    "branch_name": branch_name,
                    "pr_url": pr_url,
                    "commit_message": commit_message,
                    "pr_title": pr_title,
                },
            )

        except Exception as exc:  # pragma: no cover - handled by workflow logging
            return AgentResult(
                success=False,
                changes=[],
                message=f"Failed to submit pull request: {exc}",
                metadata={"error": str(exc)},
            )

    def _generate_branch_name(self) -> str:
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
        return f"obsidian-agents/workflow-{timestamp}"

    def _generate_commit_message(
        self, strategy: str, node_results: dict, changes: list[FileChange]
    ) -> str:
        summary_parts = []
        for node_name, result in node_results.items():
            if result.get("success") and node_name != self.name:
                summary_parts.append(f"- {node_name}: {result['message']}")

        summary = "\n".join(summary_parts) if summary_parts else "Workflow completed"

        creates = sum(1 for change in changes if change.action is FileAction.CREATE)
        updates = sum(1 for change in changes if change.action is FileAction.UPDATE)
        deletes = sum(1 for change in changes if change.action is FileAction.DELETE)

        op_counts = {
            "created": creates,
            "updated": updates,
            "deleted": deletes,
        }
        operations = [f"{count} {op}" for op, count in op_counts.items() if count]
        operations_str = ", ".join(operations) if operations else "no changes"

        return f"""Automated vault improvements via {strategy} strategy

{summary}

Files: {operations_str}

ü§ñ Generated by Obsidian Agents Workflow
"""

    def _generate_pr_content(
        self, strategy: str, node_results: dict, changes: list[FileChange]
    ) -> tuple[str, str]:
        if strategy == "research_proposal":
            deep_research_result = node_results.get("deep_research", {})
            proposal_metadata = deep_research_result.get("metadata", {})
            proposal_filename = proposal_metadata.get(
                "proposal_filename", "research proposal"
            )
            title = (
                "Research Proposal: "
                f"{proposal_filename.replace('.md', '').replace('-', ' ').title()}"
            )
        else:
            title = f"Automated vault improvements ({strategy})"

        excluded_nodes = {self.name}
        user_facing_results = {
            name: res
            for name, res in node_results.items()
            if name not in excluded_nodes
        }

        summary_parts = []
        for node_name, result in user_facing_results.items():
            if result.get("success"):
                summary_parts.append(f"- {node_name}: {result['message']}")
        summary = "\n".join(summary_parts)

        if strategy == "research_proposal":
            body_parts = [
                "## Research Proposal",
                "\n### Overview",
                "This PR contains a new research proposal generated from a user prompt.",
            ]

            article_proposal_result = node_results.get("article_proposal", {})
            article_metadata = article_proposal_result.get("metadata", {})

            if "topic_title" in article_metadata:
                body_parts.append(f"\n**Topic**: {article_metadata['topic_title']}")
            if "tags" in article_metadata:
                tags_str = ", ".join(article_metadata["tags"])
                body_parts.append(f"**Tags**: {tags_str}")

            deep_metadata = proposal_metadata
            if "sources_count" in deep_metadata:
                body_parts.append(
                    f"**Sources**: {deep_metadata['sources_count']} references"
                )

            body_parts.extend(
                [
                    "\n### Summary",
                    summary,
                    "\n### Details",
                    f"- **Proposal File**: {deep_metadata.get('proposal_path', 'N/A')}",
                    f"- **Total Changes**: {len(changes)} file operation(s)",
                    f"- **Nodes Executed**: {len(user_facing_results)}",
                ]
            )
        else:
            body_parts = [
                "## Automated Vault Improvements",
                f"\n**Strategy**: {strategy}",
                "\n### Summary",
                summary,
                "\n### Details",
                f"- **Total Changes**: {len(changes)} file operations",
                f"- **Nodes Executed**: {len(user_facing_results)}",
            ]

        body_parts.append("\n### Node Results")

        for node_name, result in user_facing_results.items():
            body_parts.append(f"\n#### {node_name}")
            body_parts.append(
                f"- Status: {'‚úÖ Success' if result.get('success') else '‚ùå Failed'}"
            )
            body_parts.append(f"- Message: {result.get('message')}")
            body_parts.append(f"- Changes: {result.get('changes_count')}")

        body_parts.append("\n---\n*Generated by Obsidian Nodes Workflow Automation*")

        body = "\n".join(body_parts)

        return title, body
